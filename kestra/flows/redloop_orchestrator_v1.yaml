id: redloop_orchestrator_v1
namespace: redloop.security

description: |
  RedLoop Security Assessment - AI-Powered Vulnerability Scanner
  Streams progress, logs, and AI outputs via webhooks for real-time UI

labels:
  project: redloop
  type: security-scan
  version: v1

triggers:
  - id: webhook
    type: io.kestra.plugin.core.trigger.Webhook
    key: "redloop_secret"

inputs:
  - id: repository_url
    type: STRING
    description: "GitHub repository URL to analyze"
    defaults: "https://github.com/kestra-io/scripts"
  
  - id: branch
    type: STRING
    defaults: "main"
    description: "Branch to analyze"

  - id: backend_url
    type: STRING
    defaults: "http://redloop-backend:8000"
    description: "Backend URL for webhooks"

tasks:
  - id: notify_start
    type: io.kestra.plugin.core.http.Request
    allowFailure: true
    uri: "{{ inputs.backend_url }}/webhook/task-update"
    method: POST
    contentType: application/json
    body: |
      {"execution_id": "{{ execution.id }}", "task_id": "start", "status": "RUNNING", "message": "üöÄ Starting scan for {{ inputs.repository_url }} ({{ inputs.branch }})"}

  - id: clone_and_scan
    type: io.kestra.plugin.core.flow.WorkingDirectory
    tasks:
      - id: clone_repository
        type: io.kestra.plugin.git.Clone
        url: "{{ inputs.repository_url }}"
        branch: "{{ inputs.branch }}"
        timeout: PT2M

      - id: read_code
        type: io.kestra.plugin.scripts.shell.Commands
        timeout: PT1M
        commands:
          - |
            FILE_COUNT=$(find . -type f \( -name "*.py" -o -name "*.js" -o -name "*.ts" -o -name "*.java" -o -name "*.go" \) | grep -v node_modules | grep -v .git | wc -l)
            echo "Found $FILE_COUNT code files"
            for f in $(find . -type f \( -name "*.py" -o -name "*.js" -o -name "*.ts" -o -name "*.java" -o -name "*.go" \) | grep -v node_modules | grep -v .git | head -20); do
              echo "=== FILE: $f ==="
              head -150 "$f"
              echo ""
            done > code_content.txt
            echo "Prepared $FILE_COUNT files for analysis"
        outputFiles:
          - code_content.txt

  - id: notify_clone_done
    type: io.kestra.plugin.core.http.Request
    allowFailure: true
    uri: "{{ inputs.backend_url }}/webhook/task-update"
    method: POST
    contentType: application/json
    body: |
      {"execution_id": "{{ execution.id }}", "task_id": "clone_repository", "status": "SUCCESS", "message": "üì• Repository cloned successfully"}

  - id: notify_adversary_start
    type: io.kestra.plugin.core.http.Request
    allowFailure: true
    uri: "{{ inputs.backend_url }}/webhook/task-update"
    method: POST
    contentType: application/json
    body: |
      {"execution_id": "{{ execution.id }}", "task_id": "adversary_kestra", "status": "RUNNING", "message": "üî¥ Adversary AI scanning for vulnerabilities..."}

  - id: adversary_kestra
    type: io.kestra.plugin.ai.agent.AIAgent
    description: "Vulnerability Scanner"
    timeout: PT5M
    retry:
      type: constant
      maxAttempt: 2
      interval: PT15S
    provider:
      type: io.kestra.plugin.ai.provider.GoogleGemini
      apiKey: "{{ secret('GEMINI_API_KEY') }}"
      modelName: gemini-2.5-flash
    prompt: |
      You are a security code auditor. Analyze the ACTUAL code below for REAL vulnerabilities.
      
      CODE TO ANALYZE:
      {{ read(outputs.read_code.outputFiles['code_content.txt']) }}
      
      STRICT RULES:
      1. ONLY report vulnerabilities that you can point to with EXACT file path and line reference from the code above
      2. NEVER invent or assume vulnerabilities - if the code doesn't show a vulnerability, it doesn't exist
      3. For each vulnerability, quote the EXACT vulnerable code snippet from the provided code
      4. If no vulnerabilities are found, return an empty array
      5. DO NOT make up file names or code that isn't in the provided content
      
      Look for these patterns in the ACTUAL provided code:
      - SQL injection (unsanitized user input in SQL queries)
      - XSS (unsanitized output to HTML)
      - Command injection (user input in shell commands)
      - Path traversal (user input in file paths without validation)
      - Hardcoded secrets (API keys, passwords in code)
      - Insecure deserialization
      
      Output ONLY valid JSON in this format:
      {
        "vulnerabilities": [
          {
            "id": "VULN-001",
            "type": "SQL Injection",
            "severity": "HIGH",
            "file": "exact_file_path_from_code.py",
            "line_reference": "Around line X in the provided code",
            "vulnerable_code": "EXACT code snippet copied from above",
            "description": "Why this is vulnerable",
            "fix": "How to fix it"
          }
        ],
        "summary": {"total": 0, "critical": 0, "high": 0, "medium": 0, "low": 0},
        "recommendation": "PASS or BLOCK",
        "analysis_note": "Brief note on what was analyzed"
      }
      
      If the code is secure or you cannot find real vulnerabilities with exact code references, return:
      {"vulnerabilities": [], "summary": {"total": 0, "critical": 0, "high": 0, "medium": 0, "low": 0}, "recommendation": "PASS", "analysis_note": "No vulnerabilities found with exact code evidence"}
    systemMessage: You are a precise security auditor. You ONLY report vulnerabilities you can prove with exact code citations from the provided input. Never hallucinate or guess. If unsure, report nothing.

  - id: notify_adversary_done
    type: io.kestra.plugin.core.http.Request
    allowFailure: true
    uri: "{{ inputs.backend_url }}/webhook/task-update"
    method: POST
    contentType: application/json
    body: |
      {"execution_id": "{{ execution.id }}", "task_id": "adversary_kestra", "status": "SUCCESS", "message": "üî¥ Adversary scan complete", "output": {{ outputs.adversary_kestra.textOutput | default('"No output"') | json }}}

  - id: notify_summarizer_start
    type: io.kestra.plugin.core.http.Request
    allowFailure: true
    uri: "{{ inputs.backend_url }}/webhook/task-update"
    method: POST
    contentType: application/json
    body: |
      {"execution_id": "{{ execution.id }}", "task_id": "summarizer_agent", "status": "RUNNING", "message": "üìã Analyzing findings and calculating risk score..."}

  - id: summarizer_agent
    type: io.kestra.plugin.ai.agent.AIAgent
    description: "Risk Assessment"
    timeout: PT3M
    retry:
      type: constant
      maxAttempt: 2
      interval: PT15S
    provider:
      type: io.kestra.plugin.ai.provider.GoogleGemini
      apiKey: "{{ secret('GEMINI_API_KEY') }}"
      modelName: gemini-2.5-flash
    prompt: |
      Analyze vulnerability report and make deployment decision:
      
      FINDINGS:
      {{ outputs.adversary_kestra.textOutput | default('No vulnerabilities found') }}
      
      Output JSON:
      {"summary": "2-3 sentence executive summary", "risk_score": 7, "decision": "BLOCK or PASS", "vulnerability_counts": {"critical": 0, "high": 0, "medium": 0, "low": 0, "total": 0}}
      
      BLOCK if any CRITICAL or 3+ HIGH, PASS otherwise.
    systemMessage: Be decisive. Always include BLOCK or PASS. Output valid JSON only.

  - id: notify_summarizer_done
    type: io.kestra.plugin.core.http.Request
    allowFailure: true
    uri: "{{ inputs.backend_url }}/webhook/task-update"
    method: POST
    contentType: application/json
    body: |
      {"execution_id": "{{ execution.id }}", "task_id": "summarizer_agent", "status": "SUCCESS", "message": "üìã Risk assessment complete", "output": {{ outputs.summarizer_agent.textOutput | default('"No output"') | json }}}

  - id: notify_defender_start
    type: io.kestra.plugin.core.http.Request
    allowFailure: true
    uri: "{{ inputs.backend_url }}/webhook/task-update"
    method: POST
    contentType: application/json
    body: |
      {"execution_id": "{{ execution.id }}", "task_id": "defender_agent", "status": "RUNNING", "message": "üõ°Ô∏è Generating security fixes..."}

  - id: defender_agent
    type: io.kestra.plugin.ai.agent.AIAgent
    description: "Generate Fixes"
    timeout: PT5M
    retry:
      type: constant
      maxAttempt: 2
      interval: PT15S
    provider:
      type: io.kestra.plugin.ai.provider.GoogleGemini
      apiKey: "{{ secret('GEMINI_API_KEY') }}"
      modelName: gemini-2.5-flash
    prompt: |
      Generate fixes for these vulnerabilities:
      {{ outputs.summarizer_agent.textOutput }}
      
      Output JSON with code fixes for each vulnerability.
    systemMessage: Generate production-ready secure code fixes. Output valid JSON only.

  - id: notify_defender_done
    type: io.kestra.plugin.core.http.Request
    allowFailure: true
    uri: "{{ inputs.backend_url }}/webhook/task-update"
    method: POST
    contentType: application/json
    body: |
      {"execution_id": "{{ execution.id }}", "task_id": "defender_agent", "status": "SUCCESS", "message": "üõ°Ô∏è Security fixes generated", "output": {{ outputs.defender_agent.textOutput | default('"No output"') | json }}}

  - id: notify_report_start
    type: io.kestra.plugin.core.http.Request
    allowFailure: true
    uri: "{{ inputs.backend_url }}/webhook/task-update"
    method: POST
    contentType: application/json
    body: |
      {"execution_id": "{{ execution.id }}", "task_id": "final_report", "status": "RUNNING", "message": "üìä Generating executive report..."}

  - id: final_report
    type: io.kestra.plugin.ai.agent.AIAgent
    description: "Executive Report"
    timeout: PT3M
    provider:
      type: io.kestra.plugin.ai.provider.GoogleGemini
      apiKey: "{{ secret('GEMINI_API_KEY') }}"
      modelName: gemini-2.5-flash
    prompt: |
      Generate security report for {{ inputs.repository_url }}:
      Decision: {{ outputs.summarizer_agent.textOutput }}
      Fixes: {{ outputs.defender_agent.textOutput }}
      
      Create markdown report with: security posture, key findings, recommended actions.
    systemMessage: Be concise and actionable.

  - id: notify_complete
    type: io.kestra.plugin.core.http.Request
    allowFailure: true
    uri: "{{ inputs.backend_url }}/webhook/task-update"
    method: POST
    contentType: application/json
    body: |
      {"execution_id": "{{ execution.id }}", "task_id": "complete", "status": "SUCCESS", "message": "‚úÖ Security assessment complete!", "output": {{ outputs.final_report.textOutput | default('"No report"') | json }}}

  - id: complete
    type: io.kestra.plugin.core.log.Log
    message: "RedLoop Security Assessment Complete!"

errors:
  - id: notify_error
    type: io.kestra.plugin.core.http.Request
    allowFailure: true
    uri: "{{ inputs.backend_url }}/webhook/execution-update"
    method: POST
    contentType: application/json
    body: |
      {"execution_id": "{{ execution.id }}", "state": "FAILED", "message": "‚ùå Scan failed - check Kestra logs for details"}
